<html><head><title>Name</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.01,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008006 at Wed Jul  6 02:46:58 2005 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Name"
>Name</a></h1>

<p>Test.More - A framework for writing test scripts</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Synopsis"
>Synopsis</a></h1>

<pre lang='und' xml:lang='und'>  &#60;pre id=&#34;test&#34;&#62;
    &#60;script type=&#34;text/javascript&#34;&#62;
      plan({ tests: numTests });
      // or
      plan({ noPlan: true });
      // or
      plan({ skipAll: reason });</pre>

<pre lang='und' xml:lang='und'>      // Various ways to say &#34;ok&#34;
      ok(got == expected, testDescription);

      is(got, expected,   testDescription);
      isnt(got, expected, testDescription);

      // Rather than document.write(&#34;# here&#39;s what went wrong\n&#34;)
      diag(&#34;here&#39;s what went wrong&#34;);

      like(got, /expected/, testDescription);
      unlike(got, &#39;expected&#39;, testDescription);

      cmpOK(got, &#39;==&#39;, expected, testDescription);

      isDeeply(complexStructure1, complexStructure2, testDescription);

      if (!haveSomeFeature) skip(why, howMany);
      else {
          ok( foo(),       testDescription );
          is( foo(42), 23, testDescription );
      }

      TODO: {
          todo(why, howMany);
          ok( foo(),       testDescription );
          is( foo(42), 23, testDescription );
      };

      canOK(module, method);
      isaOK(object, class);

      pass(testDescription);
      fail(testDescription);

      isSet(gotArray, expectedArray, testDescription);
    &#60;/script&#62;
  &#60;/pre&#62;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Description"
>Description</a></h1>

<p><b>STOP!</b> If you&#39;re just getting started writing tests, have a look at <a href="https://metacpan.org/pod/Test.Simple" class="podlinkpod"
>Test.Simple</a> first. This is a drop in replacement for Test.Simple that you can switch to once you get the hang of basic testing.</p>

<p>The purpose of this module is to provide a wide range of testing utilities. Various ways to say &#34;ok&#34; with better diagnostics, facilities to skip tests, test future features and compare complicated data structures. While you can do almost anything with a simple <code lang='und' xml:lang='und'>ok()</code> function, it doesn&#39;t provide good diagnostic output.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="I_love_it_when_a_plan_comes_together"
>I love it when a plan comes together</a></h2>

<p>Before anything else, you need a an HTML element in which to run the tests, and you need a testing plan. The HTML element must have the ID &#34;test&#34; so that, when all test finish running, Test.More can check everything over and possibly output a test status message in the event that something has gone wrong.</p>

<p>A testing plan declares how many tests your script is going to run to protect against premature failure. The preferred way to create a testing plan is to use the <code lang='und' xml:lang='und'>plan()</code> function:</p>

<pre lang='und' xml:lang='und'>  plan({ tests: numTests });</pre>

<p>There are rare cases when you will not know beforehand how many tests your script is going to run. In this case, you can declare that you have no plan. (Try to avoid using this as it weakens your test.)</p>

<pre lang='und' xml:lang='und'>  plan({ noPlan: true });</pre>

<p>In some cases, you&#39;ll want to completely skip an entire testing script.</p>

<pre lang='und' xml:lang='und'>  plan({ skipAll: reason });</pre>

<p>Your script will declare a skip with the reason why you skipped and exit immediately with a zero (success).</p>

<p>You can also calculate the number of tests:</p>

<pre lang='und' xml:lang='und'>  plan({ tests: someArray.length });</pre>

<p>or to decide between running the tests at all:</p>

<pre lang='und' xml:lang='und'>  if (!window.XMLHttpRequest) {
      plan({ skipAall:  &#39;Test irrelevant in IE&#39; });
  } else {
      plan({ tests: 42 });
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Test_Descriptions"
>Test Descriptions</a></h2>

<p>By convention, each test is assigned a number in order. This is largely done automatically. However, it&#39;s often very useful to assign a description to each test. Which would you rather see:</p>

<pre lang='und' xml:lang='und'>  ok 4
  not ok 5
  ok 6</pre>

<p>or</p>

<pre lang='und' xml:lang='und'>  ok 4 - basic multi-variable
  not ok 5 - simple exponential
  ok 6 - force == mass * acceleration</pre>

<p>The latter gives you some idea of what failed. It also makes it easier to find the test in your script: simply search for &#34;simple exponential&#34;.</p>

<p>All test functions take a description argument. It&#39;s optional, but highly suggested that you use it.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="I&#39;m_ok,_you&#39;re_not_ok."
>I&#39;m ok, you&#39;re not ok.</a></h2>

<p>The basic purpose of this library is to print out either &#34;ok #&#34; or &#34;not ok #&#34; depending on whether a given test succeeded or failed. Everything else is just gravy.</p>

<p>All of the following functions print &#34;ok&#34; or &#34;not ok&#34; depending on if the test succeeded or failed. They all also return true or false, respectively.</p>

<dl>
<dt><a name="ok"
><b>ok</b></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  ok(got == expected, testDescription);</pre>

<dd>This function simply evaluates any expression (<code lang='und' xml:lang='und'>got == expected</code> is just a simple example) and uses its value to determine whether the test succeeded or failed. A true expression passes, a false one fails. Very simple.</dd><p class="pad"></p>

<dd>For example:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    ok( exp{9} == 81,   &#39;simple exponential&#39; );
    ok( p.tests == 4,   &#39;saw tests&#39; );
    ok( items.length,  &#39;items populated&#39;);</pre>

<dd>(Mnemonic: &#34;This is ok.&#34;)</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>testDescription</code> is a very short description of the test to be printed out. It makes it very easy to find a test in your script when it fails and gives others an idea of your intentions. <code lang='und' xml:lang='und'>testDescription</code> is optional, but we <b>very</b> strongly encourage its use.</dd><p class="pad"></p>

<dd>Should an ok() fail, it will produce some diagnostics:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    not ok 18 - sufficient mucus
    #     Failed test 18 (foo.t at line 42)</pre>

<dd>This is actually the same as Test.Simple&#39;s ok() function.</dd><p class="pad"></p>

<dt><a name="is"
><b>is</b></a></dt><p class="pad"></p>

<dt><a name="isnt"
><b>isnt</b></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  is  ( got, expected, testDescription );
  isnt( got, expected, testDescription );</pre>

<dd>Similar to ok(), is() and isnt() compare the stringified value of their two arguments and use the result of that to determine if the test succeeded or failed. So these:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    // Is the ultimate answer 42?
    is( ultimateAnswer(), 42, &#34;Meaning of Life&#34; );

    // foo isn&#39;t empty
    isnt( foo, &#39;&#39;,            &#34;Got some foo&#34; );</pre>

<dd>are similar to these:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    ok( ultimateAnswer() == 42, &#34;Meaning of Life&#34; );
    ok( foo != &#39;&#39;,              &#34;Got some foo&#34; );</pre>

<dd>(Mnemonic: &#34;This is that.&#34; &#34;This isn&#39;t that.&#34;)</dd><p class="pad"></p>

<dd>So why use these functions? They produce better diagnostics on failure than does ok(). ok() cannot know what you are testing for (beyond the name), but is() and isnt() know what the test was and why it failed. For example this test:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    var foo = &#39;waffle&#39;, bar = &#39;yarblokos&#39;;
    is( foo, bar,   &#39;Is foo the same as bar?&#39; );</pre>

<dd>Will produce something like this:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    not ok 17 - Is foo the same as bar?
    #     Failed test (foo.t at line 139)
    #          got: &#39;waffle&#39;
    #     expected: &#39;yarblokos&#39;</pre>

<dd>So you can figure out what went wrong without rerunning the test.</dd><p class="pad"></p>

<dd>You are encouraged to use is() and isnt() over ok() where possible, however do not be tempted to use them to find out if something is <code lang='und' xml:lang='und'>true</code> or <code lang='und' xml:lang='und'>false</code>!</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  // XXX BAD!
  is( isFinite(brooklyn[&#39;trees&#39;]), true, &#39;Brooklyn has finite trees&#39;);</pre>

<dd>This example fails to check for whether <code lang='und' xml:lang='und'>isFinite(brooklyn[&#39;trees&#39;])</code> is true, it checks if it returns <code lang='und' xml:lang='und'>true</code>. Very different. Similar caveats exist for <code lang='und' xml:lang='und'>false</code> and 0. In these cases, use ok().</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  is( isFinite(brooklyn[&#39;trees&#39;]), &#39;Brooklyn has finite trees&#39;);</pre>

<dt><a name="like"
><b>like</b></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  like( got, /expected/, testDescription );</pre>

<dd>Similar to ok(), like() matches this against the regex <code lang='und' xml:lang='und'>/expected/</code>.</dd><p class="pad"></p>

<dd>So this:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    like(got, /expected/, &#39;got is expected&#39;);</pre>

<dd>is similar to:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    ok( /expected/.test(got), &#39;got is expected&#39;);</pre>

<dd>(Mnemonic &#34;This is like that&#34;.)</dd><p class="pad"></p>

<dd>The second argument is a regular expression. It may be given as a literal regex object (i.e. <code lang='und' xml:lang='und'>//</code> or <code lang='und' xml:lang='und'>new RegExp()</code>) or as a string that looks like a regex:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    like(got, &#39;expected&#39;, &#39;got is expected&#39;);</pre>

<dd>If &#60;got&#62; is not a string, the test will fail.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    like([], /expected/, &#39;this will fail&#39;);</pre>

<dd>The advantages of like() over ok() are similar to that of is() and isnt(). Better diagnostics on failure.</dd><p class="pad"></p>

<dt><a name="unlike"
><b>unlike</b></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  unlike( this, /that/, testDescription );</pre>

<dd>Works exactly as like(), only it checks if this <b>does not</b> match the given pattern.</dd><p class="pad"></p>

<dt><a name="cmpOK"
><b>cmpOK</b></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  cmpOK( got, op, expected, testDescription );</pre>

<dd>Halfway between ok() and is() lies cmpOK(). This function allows you to compare two arguments using any binary JavaScript operator, plus a few Perl-style binary operators for string comparisons:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    // ok( got.toString() == expected.toString() );
    cmpOK( got, &#39;eq&#39;, expected, &#39;got eq expected&#39; );

    // ok( got == expected );
    cmpOK( got, &#39;==&#39;, expected, &#39;got == expected&#39; );

    // ok( got &#38;&#38; expected );
    cmpOK( got, &#39;&#38;&#38;&#39;, expected, &#39;got &#38;&#38; expected&#39; );
    // ...etc...</pre>

<dd>The advantage of cmpOK() over ok() is when the test fails you&#39;ll know what this and that were:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    not ok 1
    #     Failed test (foo.html at line 12)
    #     &#39;23&#39;
    #         &#38;&#38;
    #     undef</pre>

<dd>It&#39;s also useful in those cases where you are comparing numbers and is()&#39;s use of string comparison will interfere:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    cmpOK( bigHairyNumber, &#39;==&#39;, anotherBigHairyNumber );</pre>

<dd>The added perl operators are:</dd><p class="pad"></p>

<dl>
<dt><a name="eq"
>eq</a></dt><p class="pad"></p>

<dd>String equivalence.</dd><p class="pad"></p>

<dt><a name="ne"
>ne</a></dt><p class="pad"></p>

<dd>String non-equivalence.</dd><p class="pad"></p>

<dt><a name="lt"
>lt</a></dt><p class="pad"></p>

<dd>String less than.</dd><p class="pad"></p>

<dt><a name="gt"
>gt</a></dt><p class="pad"></p>

<dd>String greater than.</dd><p class="pad"></p>

<dt><a name="le"
>le</a></dt><p class="pad"></p>

<dd>String less than or equal to.</dd><p class="pad"></p>

<dt><a name="ge"
>ge</a></dt><p class="pad"></p>

<dd>String greater than or equal to.</dd><p class="pad"></p>
</dl>

<dt><a name="canOK"
><b>canOK</b></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  canOK(class,  method, method, method...);
  canOK(object,  method, method, method...);</pre>

<dd>Checks to make sure the class or object can do the defined methods.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    canOK(&#39;Foo&#39;, &#39;foo&#39;, &#39;bar&#39;, &#39;whatever&#39;);</pre>

<dd>Handy for quickly testing an interface.</dd><p class="pad"></p>

<dd>No matter how many methods you check, a single canOK() call counts as one test. If you desire otherwise, use:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    for (var meth in [&#39;foo&#39;, &#39;bar&#39;, &#39;whatever&#39;]) {
        canOK(&#39;Foo&#39;, meth);
    }</pre>

<dt><a name="isaOK"
><b>isaOK</b></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  isaOK(object, class, objectName);</pre>

<dd>Checks to see if the given <code lang='und' xml:lang='und'>object</code> is a <code lang='und' xml:lang='und'>class</code>. Also checks to make sure the object was defined in the first place. Handy for this sort of thing:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    var obj = new SomeClass();
    isaOK( obj, &#39;SomeClass&#39; );</pre>

<dd>where you&#39;d otherwise have to write</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    var obj = new SomeClass();
    ok( defined obj &#38;&#38; SomeClass.constructor.prototype.isPrototypeOf(obj));</pre>

<dd>to safeguard against your test script blowing up.</dd><p class="pad"></p>

<dd>It works on core classes, too:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    isaOK( [], &#39;Array&#39; );</pre>

<dd>The diagnostics of this test normally just refer to &#39;the object&#39;. If you&#39;d like them to be more specific, you can supply an objectName (for example &#39;Test customer&#39;).</dd><p class="pad"></p>

<dd>Note that inheritance is detected only for versions of JavaScript that support the isPrototypeOf() method. Earlier versions of JavaScript will only detect an exact match for class membership.</dd><p class="pad"></p>

<dt><a name="pass"
><b>pass</b></a></dt><p class="pad"></p>

<dt><a name="fail"
><b>fail</b></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  pass(testDescription);
  fail(testDescription);</pre>

<dd>Sometimes you just want to say that the tests have passed. Usually the case is you&#39;ve got some complicated condition that is difficult to wedge into an ok(). In this case, you can simply use pass() (to declare the test ok) or fail (for not ok). They are synonyms for ok(1) and ok(0).</dd><p class="pad"></p>

<dd>Use these functions very, very, very sparingly.</dd><p class="pad"></p>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Diagnostics"
>Diagnostics</a></h2>

<p>If you pick the right test function, you&#39;ll usually get a good idea of what went wrong when it fails. But sometimes it doesn&#39;t work out that way. So here we have ways for you to write your own diagnostic messages.</p>

<dl>
<dt><a name="diag"
><b>diag</b></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  diag(message);
  diag(message, message2, message3, ...);</pre>

<dd>Prints a diagnostic message that is guaranteed not to interfere with test output. All of the arguments to diag() will simply be concatinated together.</dd><p class="pad"></p>

<dd>Handy for this sort of thing:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    ok( users[&#39;foo&#39;]), &#34;There&#39;s a foo user&#34; )
      || diag(&#34;Since there&#39;s no foo, check that /etc/bar is set up right&#34;);</pre>

<dd>which would produce:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    not ok 42 - There&#39;s a foo user
    #     Failed test (foo.html at line 52)
    # Since there&#39;s no foo, check that /etc/bar is set up right.</pre>

<dd>All diag()s can be made silent by passing the &#34;noDiag&#34; option to the plan() function: <code lang='und' xml:lang='und'>plan({ tests: 1, noDiag: true });</code>. This is useful if you have diagnostics for personal testing but then wish to make them silent for release without commenting out each individual statement.</dd><p class="pad"></p>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Conditional_tests"
>Conditional tests</a></h2>

<p>Sometimes running a test under certain conditions will cause the test script to die. A certain function or method might not be implemented (such as <code lang='und' xml:lang='und'>window.XMLHttpRequest()</code> in Internet Explorer), some resource isn&#39;t available (like a net connection) or a JavaScript class isn&#39;t available. In these cases it&#39;s necessary to skip tests, or declare that they are supposed to fail but will work in the future (a todo test).</p>

<p>For more details on the mechanics of skip and todo tests see <a href="https://metacpan.org/pod/Test.Harness" class="podlinkpod"
>Test.Harness</a>.</p>

<p>The way Test.More skips tests is with a named block. Basically, a block of tests that can be skipped over or made todo. It&#39;s best if I just show you...</p>

<dl>
<dt><a name="skip"
><b>skip</b></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  if (condition) skip(why, howMany);
  else {
      // ...normal testing code goes here...
  }</pre>

<dd>This example demonstrates how to skip a series of tests, <code lang='und' xml:lang='und'>howMany</code> tests to skip, <code lang='und' xml:lang='und'>why</code> and under what <code lang='und' xml:lang='und'>condition</code> to skip them. An example is the easiest way to illustrate:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  if (!window.XMLHttpRequest) skip(&#34;No XMLHttpRequest in your browser.&#34;, 1);
  else {
      isaOK(new XMLHttpRequest(), &#39;XMLHttpRequest&#39;);
  }</pre>

<dd>If the user&#39;s browser doesn&#39;t support <code lang='und' xml:lang='und'>window.XMLHttpRequest()</code>, we skip the test by calling <code lang='und' xml:lang='und'>skip()</code>. Test.More will output special <code lang='und' xml:lang='und'>ok</code>s that Test.Harness interprets as skipped, but passing, tests. If the browser does support <code lang='und' xml:lang='und'>window.XMLHttpRequest()</code>, then obviously the tests will be run as normal.</dd><p class="pad"></p>

<dd>It&#39;s important that <code lang='und' xml:lang='und'>howMany</code> accurately reflects the number of tests to skip so the number of tests run will match up with your plan. If your plan is &#34;noPlan&#34;, <code lang='und' xml:lang='und'>howMany</code> is optional and will default to 1.</dd><p class="pad"></p>

<dd>Don&#39;t skip failing tests because there&#39;s a bug in your program, or for which you have not yet written code. For that you use todo(). Read on.</dd><p class="pad"></p>

<dt><a name="todo"
><b>todo</b></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>    TODO: {
        todo(why, howMany);
        // ...normal testing code goes here...
    }</pre>

<dd>Declares a series of tests that you expect to fail and why. Perhaps it&#39;s because you haven&#39;t fixed a bug or haven&#39;t finished a new feature:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    TODO: {
        todo(&#34;URIGeller not finished&#34;, 2);

        var card = &#34;Eight of clubs&#34;;
        is( URIGeller.yourCard(), card, &#39;Is THIS your card?&#39; );

        var spoon;
        URIGeller.bendSpoon();
        is( spoon, &#39;bent&#39;,    &#34;Spoon bending, that&#39;s original&#34; );
    }</pre>

<dd>With todo(), <code lang='und' xml:lang='und'>howMany</code> specifies how many tests are expected to fail. Test.More will run the tests normally, but print out special flags indicating they are &#34;todo&#34; tests. Test.Harness will interpret these failures as ok. Should any todo test, it Test.Harness will report it as an unexpected success. You then know the thing you had todo is done and can remove the call to todo().</dd><p class="pad"></p>

<dd>The nice part about todo tests, as opposed to simply commenting out a block of tests, is that they&#39;re like a programmatic todo list. You know how much work is left to be done, you&#39;re aware of what bugs there are, and you&#39;ll know immediately when they&#39;re fixed.</dd><p class="pad"></p>

<dd>It&#39;s a good idea to label a block that contains your TODO tests so that they&#39;re easy to find. Once a todo test starts succeeding, simply move it outside the and decrement the <code lang='und' xml:lang='und'>howMany</code> argument to <code lang='und' xml:lang='und'>todo()</code>. When the block is empty, delete it.</dd><p class="pad"></p>

<dt><a name="todoSkip"
><b>todoSkip</b></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  if (condition) todoSkip(why, howMany);
  else {
      // ...normal testing code...
  }</pre>

<dd>With todo tests, it&#39;s best to have the tests actually run. That way you&#39;ll know when they start passing. But sometimes this isn&#39;t possible. Often a failing test will cause the whole program to die or hang. In such extreme cases you have no choice but to skip over the broken tests entirely.</dd><p class="pad"></p>

<dd>The syntax and behavior of todoSkip() is similar to that of <code lang='und' xml:lang='und'>skip()</code> except the tests will be marked as failing but todo. Test.Harness will interpret them as passing.</dd><p class="pad"></p>

<dt><a name="When_do_I_use_skip()_vs._todo()?"
>When do I use skip() vs. todo()?</a></dt><p class="pad"></p>

<dd><b>If it&#39;s something the user might not be able to do</b>, use skip(). This includes optional classes that aren&#39;t loaded, running in a browser that doesn&#39;t have some feature, or maybe running on a platform without an Internet connection.</dd><p class="pad"></p>

<dd><b>If it&#39;s something the programmer hasn&#39;t yet done</b>, use todo(). This feature is for any code you haven&#39;t written yet, or bugs you have yet to fix, but when want to test them, anyway (always a good idea).</dd><p class="pad"></p>

<dt><a name="skipRest"
><b>skipRest</b></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  if (condition) skipRest(why);
  // ...normal testing code</pre>

<dd>Sometimes you may have structured your tests so that you expect them all work up to a certain point, but perhaps not beyond that point. Use skipRest() at that point to skip all of the rest of the tests in the test file. This is effectively a shortcut for <code lang='und' xml:lang='und'>skip(why, howMany)</code>, but you don&#39;t have to count how many tests to skip to get to the end of the test file.</dd><p class="pad"></p>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Comparison_functions"
>Comparison functions</a></h2>

<p>Not everything is a simple equality check or regular expression comparison. There are times you need to see if two arrays are equivalent, for instance. For these instances, Test.More provides a handful of useful functions.</p>

<dl>
<dt><a name="isDeeply"
><b>isDeeply</b></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  isDeeply( got, expected, testDescription );</pre>

<dd>Similar to is(), except that if <code lang='und' xml:lang='und'>got</code> and <code lang='und' xml:lang='und'>expected</code> are arrays or objects, it does a deep comparison, walking each data structure to see if they are equivalent. If the two structures are different, isDeeply() will output diagnostics identifying where they start differing.</dd><p class="pad"></p>

<dt><a name="isSet"
><b>isSet</b></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  isSet(gotArray, expectedArray, testDescription);</pre>

<dd>This function tests that two arrays have the same values, but unlike in isDeeply(), the order of the elements is <b>not</b> important. Only values are compared, not the keys (so it makes no difference whether you pass in a numeric array or an associative array). Note that this is a deep check, but the irrelevance of order only applies to the top level.</dd><p class="pad"></p>

<dd>In the event of test failure, the diagnostic output will, as usual, indicate where the two sets differ. However, since the arrays are sorted, the values may not be in the same order (that is, with the same array indices) as they appeared in the arrays passed to isSet().</dd><p class="pad"></p>

<dd><b>NOTE:</b> By historical accident, this is not a true set comparison. While the order of elements does not matter, duplicate elements do matter.</dd><p class="pad"></p>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Extending_and_Embedding_Test.More"
>Extending and Embedding Test.More</a></h2>

<p>Sometimes the Test.More interface isn&#39;t quite enough. Fortunately, Test.More is built on top of Test.Builder, which provides a single, unified back end for any test library to use. This means two test libraries that both use Test.Builder <b>can be used together in the same program</b>.</p>

<p>If you simply want to do a little tweaking of how the tests behave, you can access the underlying Test.Builder object like so:</p>

<dl>
<dt><a name="builder"
><b>builder</b></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>    var testBuilder = Test.More.builder();</pre>

<dd>Returns the Test.Builder object underlying Test.More for you to play with.</dd><p class="pad"></p>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="See_Also"
>See Also</a></h1>

<dl>
<dt><a name="Test.Simple"
><a href="https://metacpan.org/pod/Test.Simple" class="podlinkpod"
>Test.Simple</a></a></dt><p class="pad"></p>

<dd>If all of these test functions confuse you and you just want to write some simple tests. You can upgrade to Test.More later (it&#39;s forward compatible).</dd><p class="pad"></p>

<dt><a name="http://www.edwardh.com/jsunit/"
><a href="http://www.edwardh.com/jsunit/" class="podlinkurl"
>http://www.edwardh.com/jsunit/</a></a></dt><p class="pad"></p>

<dd>JSUnit: elaborate xUnit-style testing framework.</dd><p class="pad"></p>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Authors"
>Authors</a></h1>

<p>Michael G Schwern &#60;schwern@pobox.com&#62; with much inspiration from Joshua Pritikin&#39;s Test module and lots of help from Barrie Slaymaker, Tony Bowden, blackstar.co.uk, chromatic, Fergal Daly and the perl-qa gang. JavaScript implementation by David Wheeler &#60;david@kineticode.com&#62;.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Copyright"
>Copyright</a></h1>

<p>Copyright 2001, 2002, 2004 by Michael G Schwern &#60;schwern@pobox.com&#62;, 2005 by David Wheeler.</p>

<p>This program is free software; you can redistribute it and/or modify it under the terms of the Perl Artistic License or the GNU GPL.</p>

<p>See <a href="http://www.perl.com/perl/misc/Artistic.html" class="podlinkurl"
>http://www.perl.com/perl/misc/Artistic.html</a> and <a href="http://www.gnu.org/copyleft/gpl.html" class="podlinkurl"
>http://www.gnu.org/copyleft/gpl.html</a>.</p>

<!-- end doc -->

</body></html>
