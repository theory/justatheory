<html><head><title>Name</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.03,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.010000 at Wed Apr  2 03:19:48 2008 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Name"
>Name</a></h1>

<p>Test.More - A framework for writing test scripts</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Synopsis"
>Synopsis</a></h1>

<pre>  &#60;pre id=&#34;test&#34;&#62;
    &#60;script type=&#34;text/javascript&#34;&#62;
      plan({ tests: numTests });
      // or
      plan({ noPlan: true });
      // or
      plan({ skipAll: reason });</pre>

<pre>      // Various ways to say &#34;ok&#34;
      ok(got == expected, testDescription);

      is(got, expected,   testDescription);
      isnt(got, expected, testDescription);

      // Rather than document.write(&#34;# here&#39;s what went wrong\n&#34;)
      diag(&#34;here&#39;s what went wrong&#34;);

      like(got, /expected/, testDescription);
      unlike(got, &#39;expected&#39;, testDescription);

      cmpOK(got, &#39;==&#39;, expected, testDescription);

      isDeeply(complexStructure1, complexStructure2, testDescription);

      if (!haveSomeFeature) skip(why, howMany);
      else {
          ok( foo(),       testDescription );
          is( foo(42), 23, testDescription );
      }

      TODO: {
          todo(why, howMany);
          ok( foo(),       testDescription );
          is( foo(42), 23, testDescription );
      };

      canOK(module, method);
      isaOK(object, class);

      pass(testDescription);
      fail(testDescription);

      isSet(gotArray, expectedArray, testDescription);
    &#60;/script&#62;
  &#60;/pre&#62;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Description"
>Description</a></h1>

<p><b>STOP!</b> If you&#39;re just getting started writing tests, have a look at <a href="https://metacpan.org/pod/Test.Simple" class="podlinkpod"
>Test.Simple</a> first. This is a drop in replacement for Test.Simple that you can switch to once you get the hang of basic testing.</p>

<p>The purpose of this module is to provide a wide range of testing utilities. Various ways to say &#34;ok&#34; with better diagnostics, facilities to skip tests, test future features and compare complicated data structures. While you can do almost anything with a simple <code>ok()</code> function, it doesn&#39;t provide good diagnostic output.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="I_love_it_when_a_plan_comes_together"
>I love it when a plan comes together</a></h2>

<p>Before anything else, you need a an HTML element in which to run the tests, and you need a testing plan. The HTML element must have the ID &#34;test&#34; so that, when all test finish running, Test.More can check everything over and possibly output a test status message in the event that something has gone wrong.</p>

<p>A testing plan declares how many tests your script is going to run to protect against premature failure. The preferred way to create a testing plan is to use the <code>plan()</code> function:</p>

<pre>  plan({ tests: numTests });</pre>

<p>There are rare cases when you will not know beforehand how many tests your script is going to run. In this case, you can declare that you have no plan. (Try to avoid using this as it weakens your test.)</p>

<pre>  plan({ noPlan: true });</pre>

<p>In some cases, you&#39;ll want to completely skip an entire testing script.</p>

<pre>  plan({ skipAll: reason });</pre>

<p>Your script will declare a skip with the reason why you skipped and exit immediately with a zero (success).</p>

<p>You can also calculate the number of tests:</p>

<pre>  plan({ tests: someArray.length });</pre>

<p>or to decide between running the tests at all:</p>

<pre>  if (!window.XMLHttpRequest) {
      plan({ skipAall:  &#39;Test irrelevant in IE&#39; });
  } else {
      plan({ tests: 42 });
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Test_Descriptions"
>Test Descriptions</a></h2>

<p>By convention, each test is assigned a number in order. This is largely done automatically. However, it&#39;s often very useful to assign a description to each test. Which would you rather see:</p>

<pre>  ok 4
  not ok 5
  ok 6</pre>

<p>or</p>

<pre>  ok 4 - basic multi-variable
  not ok 5 - simple exponential
  ok 6 - force == mass * acceleration</pre>

<p>The latter gives you some idea of what failed. It also makes it easier to find the test in your script: simply search for &#34;simple exponential&#34;.</p>

<p>All test functions take a description argument. It&#39;s optional, but highly suggested that you use it.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="I&#39;m_ok,_you&#39;re_not_ok."
>I&#39;m ok, you&#39;re not ok.</a></h2>

<p>The basic purpose of this library is to print out either &#34;ok #&#34; or &#34;not ok #&#34; depending on whether a given test succeeded or failed. Everything else is just gravy.</p>

<p>All of the following functions print &#34;ok&#34; or &#34;not ok&#34; depending on if the test succeeded or failed. They all also return true or false, respectively.</p>

<dl>
<dt><a name="ok"
><b>ok</b></a></dt>

<dd>
<pre>  ok(got == expected, testDescription);</pre>

<p>This function simply evaluates any expression (<code>got == expected</code> is just a simple example) and uses its value to determine whether the test succeeded or failed. A true expression passes, a false one fails. Very simple.</p>

<p>For example:</p>

<pre>    ok( exp{9} == 81,   &#39;simple exponential&#39; );
    ok( p.tests == 4,   &#39;saw tests&#39; );
    ok( items.length,  &#39;items populated&#39;);</pre>

<p>(Mnemonic: &#34;This is ok.&#34;)</p>

<p><code>testDescription</code> is a very short description of the test to be printed out. It makes it very easy to find a test in your script when it fails and gives others an idea of your intentions. <code>testDescription</code> is optional, but we <b>very</b> strongly encourage its use.</p>

<p>Should an ok() fail, it will produce some diagnostics:</p>

<pre>    not ok 18 - sufficient mucus
    #     Failed test 18 (foo.t at line 42)</pre>

<p>This is actually the same as Test.Simple&#39;s ok() function.</p>

<dt><a name="is"
><b>is</b>
<dt><a name="isnt"
><b>isnt</b></a></dt>

<dd>
<pre>  is  ( got, expected, testDescription );
  isnt( got, expected, testDescription );</pre>

<p>Similar to ok(), is() and isnt() compare the stringified value of their two arguments and use the result of that to determine if the test succeeded or failed. So these:</p>

<pre>    // Is the ultimate answer 42?
    is( ultimateAnswer(), 42, &#34;Meaning of Life&#34; );

    // foo isn&#39;t empty
    isnt( foo, &#39;&#39;,            &#34;Got some foo&#34; );</pre>

<p>are similar to these:</p>

<pre>    ok( ultimateAnswer() == 42, &#34;Meaning of Life&#34; );
    ok( foo != &#39;&#39;,              &#34;Got some foo&#34; );</pre>

<p>(Mnemonic: &#34;This is that.&#34; &#34;This isn&#39;t that.&#34;)</p>

<p>So why use these functions? They produce better diagnostics on failure than does ok(). ok() cannot know what you are testing for (beyond the name), but is() and isnt() know what the test was and why it failed. For example this test:</p>

<pre>    var foo = &#39;waffle&#39;, bar = &#39;yarblokos&#39;;
    is( foo, bar,   &#39;Is foo the same as bar?&#39; );</pre>

<p>Will produce something like this:</p>

<pre>    not ok 17 - Is foo the same as bar?
    #     Failed test (foo.t at line 139)
    #          got: &#39;waffle&#39;
    #     expected: &#39;yarblokos&#39;</pre>

<p>So you can figure out what went wrong without rerunning the test.</p>

<p>You are encouraged to use is() and isnt() over ok() where possible, however do not be tempted to use them to find out if something is <code>true</code> or <code>false</code>!</p>

<pre>  // XXX BAD!
  is( isFinite(brooklyn[&#39;trees&#39;]), true, &#39;Brooklyn has finite trees&#39;);</pre>

<p>This example fails to check for whether <code>isFinite(brooklyn[&#39;trees&#39;])</code> is true, it checks if it returns <code>true</code>. Very different. Similar caveats exist for <code>false</code> and 0. In these cases, use ok().</p>

<pre>  is( isFinite(brooklyn[&#39;trees&#39;]), &#39;Brooklyn has finite trees&#39;);</pre>

<dt><a name="like"
><b>like</b></a></dt>

<dd>
<pre>  like( got, /expected/, testDescription );</pre>

<p>Similar to ok(), like() matches this against the regex <code>/expected/</code>.</p>

<p>So this:</p>

<pre>    like(got, /expected/, &#39;got is expected&#39;);</pre>

<p>is similar to:</p>

<pre>    ok( /expected/.test(got), &#39;got is expected&#39;);</pre>

<p>(Mnemonic &#34;This is like that&#34;.)</p>

<p>The second argument is a regular expression. It may be given as a literal regex object (i.e. <code>//</code> or <code>new RegExp()</code>) or as a string that looks like a regex:</p>

<pre>    like(got, &#39;expected&#39;, &#39;got is expected&#39;);</pre>

<p>If &#60;got&#62; is not a string, the test will fail.</p>

<pre>    like([], /expected/, &#39;this will fail&#39;);</pre>

<p>The advantages of like() over ok() are similar to that of is() and isnt(). Better diagnostics on failure.</p>

<dt><a name="unlike"
><b>unlike</b></a></dt>

<dd>
<pre>  unlike( this, /that/, testDescription );</pre>

<p>Works exactly as like(), only it checks if this <b>does not</b> match the given pattern.</p>

<dt><a name="cmpOK"
><b>cmpOK</b></a></dt>

<dd>
<pre>  cmpOK( got, op, expected, testDescription );</pre>

<p>Halfway between ok() and is() lies cmpOK(). This function allows you to compare two arguments using any binary JavaScript operator, plus a few Perl-style binary operators for string comparisons:</p>

<pre>    // ok( got.toString() == expected.toString() );
    cmpOK( got, &#39;eq&#39;, expected, &#39;got eq expected&#39; );

    // ok( got == expected );
    cmpOK( got, &#39;==&#39;, expected, &#39;got == expected&#39; );

    // ok( got &#38;&#38; expected );
    cmpOK( got, &#39;&#38;&#38;&#39;, expected, &#39;got &#38;&#38; expected&#39; );
    // ...etc...</pre>

<p>The advantage of cmpOK() over ok() is when the test fails you&#39;ll know what this and that were:</p>

<pre>    not ok 1
    #     Failed test (foo.html at line 12)
    #     &#39;23&#39;
    #         &#38;&#38;
    #     undef</pre>

<p>It&#39;s also useful in those cases where you are comparing numbers and is()&#39;s use of string comparison will interfere:</p>

<pre>    cmpOK( bigHairyNumber, &#39;==&#39;, anotherBigHairyNumber );</pre>

<p>The added perl operators are:</p>

<dl>
<dt><a name="eq"
>eq</a></dt>

<dd>
<p>String equivalence.</p>

<dt><a name="ne"
>ne</a></dt>

<dd>
<p>String non-equivalence.</p>

<dt><a name="lt"
>lt</a></dt>

<dd>
<p>String less than.</p>

<dt><a name="gt"
>gt</a></dt>

<dd>
<p>String greater than.</p>

<dt><a name="le"
>le</a></dt>

<dd>
<p>String less than or equal to.</p>

<dt><a name="ge"
>ge</a></dt>

<dd>
<p>String greater than or equal to.</p>
</dd>
</dl>

<dt><a name="canOK"
><b>canOK</b></a></dt>

<dd>
<pre>  canOK(class,  method, method, method...);
  canOK(object,  method, method, method...);</pre>

<p>Checks to make sure the class or object can do the defined methods.</p>

<pre>    canOK(&#39;Foo&#39;, &#39;foo&#39;, &#39;bar&#39;, &#39;whatever&#39;);</pre>

<p>Handy for quickly testing an interface.</p>

<p>No matter how many methods you check, a single canOK() call counts as one test. If you desire otherwise, use:</p>

<pre>    for (var meth in [&#39;foo&#39;, &#39;bar&#39;, &#39;whatever&#39;]) {
        canOK(&#39;Foo&#39;, meth);
    }</pre>

<p><b>Note:</b> Instances of classes defined by assigning anonymous objects to the <code>prototype</code> attribute of the constructor will not work properly in the <code>canOK()</code> function.</p>

<pre>  My.Class = function () {};
  My.Class.prototype = {
      foo: function () { return &#39;foo&#39; },
      bar: function () { return &#39;bar&#39; }
  };

  var my = new My.Class();
  canOK(my, &#39;foo&#39;); // Fail</pre>

<p>This is because the anonymous object assigned to the prototype is constructed by the base <code>Object</code> class, not by the <code>My.Class()</code> construtor. The workaround is to call <code>canOK()</code> with the class name, instead:</p>

<pre>  canOK(&#39;My.Class&#39;, &#39;foo&#39;); // Pass</pre>

<p>This is not an issue for prototypes that are simply assigned to:</p>

<pre>  My.Class = function () {};
  My.Class.prototype.foo = function () { return &#39;foo&#39; };
  My.Class.prototype.bar = function () { return &#39;bar&#39; };

  var my = new My.Class();
  canOK(my, &#39;foo&#39;); // Pass</pre>

<dt><a name="isaOK"
><b>isaOK</b></a></dt>

<dd>
<pre>  isaOK(object, class, objectName);</pre>

<p>Checks to see if the given <code>object</code> is a <code>class</code>. Also checks to make sure the object was defined in the first place. Handy for this sort of thing:</p>

<pre>    var obj = new SomeClass();
    isaOK( obj, &#39;SomeClass&#39; );</pre>

<p>where you&#39;d otherwise have to write</p>

<pre>    var obj = new SomeClass();
    ok( defined obj &#38;&#38; SomeClass.constructor.prototype.isPrototypeOf(obj));</pre>

<p>to safeguard against your test script blowing up.</p>

<p>It works on core classes, too:</p>

<pre>    isaOK( [], &#39;Array&#39; );</pre>

<p>The diagnostics of this test normally just refer to &#39;the object&#39;. If you&#39;d like them to be more specific, you can supply an objectName (for example &#39;Test customer&#39;).</p>

<p>Note that inheritance is detected only for versions of JavaScript that support the isPrototypeOf() method. Earlier versions of JavaScript will only detect an exact match for class membership.</p>

<dt><a name="pass"
><b>pass</b>
<dt><a name="fail"
><b>fail</b></a></dt>

<dd>
<pre>  pass(testDescription);
  fail(testDescription);</pre>

<p>Sometimes you just want to say that the tests have passed. Usually the case is you&#39;ve got some complicated condition that is difficult to wedge into an ok(). In this case, you can simply use pass() (to declare the test ok) or fail (for not ok). They are synonyms for ok(1) and ok(0).</p>

<p>Use these functions very, very, very sparingly.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Diagnostics"
>Diagnostics</a></h2>

<p>If you pick the right test function, you&#39;ll usually get a good idea of what went wrong when it fails. But sometimes it doesn&#39;t work out that way. So here we have ways for you to write your own diagnostic messages.</p>

<dl>
<dt><a name="diag"
><b>diag</b></a></dt>

<dd>
<pre>  diag(message);
  diag(message, message2, message3, ...);</pre>

<p>Prints a diagnostic message that is guaranteed not to interfere with test output. All of the arguments to diag() will simply be concatinated together.</p>

<p>Handy for this sort of thing:</p>

<pre>    ok( users[&#39;foo&#39;]), &#34;There&#39;s a foo user&#34; )
      || diag(&#34;Since there&#39;s no foo, check that /etc/bar is set up right&#34;);</pre>

<p>which would produce:</p>

<pre>    not ok 42 - There&#39;s a foo user
    #     Failed test (foo.html at line 52)
    # Since there&#39;s no foo, check that /etc/bar is set up right.</pre>

<p>All diag()s can be made silent by passing the &#34;noDiag&#34; option to the plan() function: <code>plan({ tests: 1, noDiag: true });</code>. This is useful if you have diagnostics for personal testing but then wish to make them silent for release without commenting out each individual statement.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Conditional_tests"
>Conditional tests</a></h2>

<p>Sometimes running a test under certain conditions will cause the test script to die. A certain function or method might not be implemented (such as <code>window.XMLHttpRequest()</code> in Internet Explorer), some resource isn&#39;t available (like a net connection) or a JavaScript class isn&#39;t available. In these cases it&#39;s necessary to skip tests, or declare that they are supposed to fail but will work in the future (a todo test).</p>

<p>For more details on the mechanics of skip and todo tests see <a href="https://metacpan.org/pod/Test.Harness" class="podlinkpod"
>Test.Harness</a>.</p>

<p>The way Test.More skips tests is with a named block. Basically, a block of tests that can be skipped over or made todo. It&#39;s best if I just show you...</p>

<dl>
<dt><a name="skip"
><b>skip</b></a></dt>

<dd>
<pre>  if (condition) skip(why, howMany);
  else {
      // ...normal testing code goes here...
  }</pre>

<p>This example demonstrates how to skip a series of tests, <code>howMany</code> tests to skip, <code>why</code> and under what <code>condition</code> to skip them. An example is the easiest way to illustrate:</p>

<pre>  if (!window.XMLHttpRequest) skip(&#34;No XMLHttpRequest in your browser.&#34;, 1);
  else {
      isaOK(new XMLHttpRequest(), &#39;XMLHttpRequest&#39;);
  }</pre>

<p>If the user&#39;s browser doesn&#39;t support <code>window.XMLHttpRequest()</code>, we skip the test by calling <code>skip()</code>. Test.More will output special <code>ok</code>s that Test.Harness interprets as skipped, but passing, tests. If the browser does support <code>window.XMLHttpRequest()</code>, then obviously the tests will be run as normal.</p>

<p>It&#39;s important that <code>howMany</code> accurately reflects the number of tests to skip so the number of tests run will match up with your plan. If your plan is &#34;noPlan&#34;, <code>howMany</code> is optional and will default to 1.</p>

<p>Don&#39;t skip failing tests because there&#39;s a bug in your program, or for which you have not yet written code. For that you use todo(). Read on.</p>

<dt><a name="todo"
><b>todo</b></a></dt>

<dd>
<pre>    TODO: {
        todo(why, howMany);
        // ...normal testing code goes here...
    }</pre>

<p>Declares a series of tests that you expect to fail and why. Perhaps it&#39;s because you haven&#39;t fixed a bug or haven&#39;t finished a new feature:</p>

<pre>    TODO: {
        todo(&#34;URIGeller not finished&#34;, 2);

        var card = &#34;Eight of clubs&#34;;
        is( URIGeller.yourCard(), card, &#39;Is THIS your card?&#39; );

        var spoon;
        URIGeller.bendSpoon();
        is( spoon, &#39;bent&#39;,    &#34;Spoon bending, that&#39;s original&#34; );
    }</pre>

<p>With todo(), <code>howMany</code> specifies how many tests are expected to fail. Test.More will run the tests normally, but print out special flags indicating they are &#34;todo&#34; tests. Test.Harness will interpret these failures as ok. Should any todo test, it Test.Harness will report it as an unexpected success. You then know the thing you had todo is done and can remove the call to todo().</p>

<p>The nice part about todo tests, as opposed to simply commenting out a block of tests, is that they&#39;re like a programmatic todo list. You know how much work is left to be done, you&#39;re aware of what bugs there are, and you&#39;ll know immediately when they&#39;re fixed.</p>

<p>It&#39;s a good idea to label a block that contains your TODO tests so that they&#39;re easy to find. Once a todo test starts succeeding, simply move it outside the and decrement the <code>howMany</code> argument to <code>todo()</code>. When the block is empty, delete it.</p>

<dt><a name="todoSkip"
><b>todoSkip</b></a></dt>

<dd>
<pre>  if (condition) todoSkip(why, howMany);
  else {
      // ...normal testing code...
  }</pre>

<p>With todo tests, it&#39;s best to have the tests actually run. That way you&#39;ll know when they start passing. But sometimes this isn&#39;t possible. Often a failing test will cause the whole program to die or hang. In such extreme cases you have no choice but to skip over the broken tests entirely.</p>

<p>The syntax and behavior of todoSkip() is similar to that of <code>skip()</code> except the tests will be marked as failing but todo. Test.Harness will interpret them as passing.</p>

<dt><a name="When_do_I_use_skip()_vs._todo()?"
>When do I use skip() vs. todo()?</a></dt>

<dd>
<p><b>If it&#39;s something the user might not be able to do</b>, use skip(). This includes optional classes that aren&#39;t loaded, running in a browser that doesn&#39;t have some feature, or maybe running on a platform without an Internet connection.</p>

<p><b>If it&#39;s something the programmer hasn&#39;t yet done</b>, use todo(). This feature is for any code you haven&#39;t written yet, or bugs you have yet to fix, but when want to test them, anyway (always a good idea).</p>

<dt><a name="skipRest"
><b>skipRest</b></a></dt>

<dd>
<pre>  if (condition) skipRest(why);
  // ...normal testing code</pre>

<p>Sometimes you may have structured your tests so that you expect them all work up to a certain point, but perhaps not beyond that point. Use skipRest() at that point to skip all of the rest of the tests in the test file. This is effectively a shortcut for <code>skip(why, howMany)</code>, but you don&#39;t have to count how many tests to skip to get to the end of the test file.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Comparison_functions"
>Comparison functions</a></h2>

<p>Not everything is a simple equality check or regular expression comparison. There are times you need to see if two arrays are equivalent, for instance. For these instances, Test.More provides a handful of useful functions.</p>

<dl>
<dt><a name="isDeeply"
><b>isDeeply</b></a></dt>

<dd>
<pre>  isDeeply( got, expected, testDescription );</pre>

<p>Similar to is(), except that if <code>got</code> and <code>expected</code> are arrays or objects, it does a deep comparison, walking each data structure to see if they are equivalent. If the two structures are different, isDeeply() will output diagnostics identifying where they start differing.</p>

<dt><a name="isSet"
><b>isSet</b></a></dt>

<dd>
<pre>  isSet(gotArray, expectedArray, testDescription);</pre>

<p>This function tests that two arrays have the same values, but unlike in isDeeply(), the order of the elements is <b>not</b> important. Only values are compared, not the keys (so it makes no difference whether you pass in a numeric array or an associative array). Note that this is a deep check, but the irrelevance of order only applies to the top level.</p>

<p>In the event of test failure, the diagnostic output will, as usual, indicate where the two sets differ. However, since the arrays are sorted, the values may not be in the same order (that is, with the same array indices) as they appeared in the arrays passed to isSet().</p>

<p><b>NOTE:</b> By historical accident, this is not a true set comparison. While the order of elements does not matter, duplicate elements do matter.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Extending_and_Embedding_Test.More"
>Extending and Embedding Test.More</a></h2>

<p>Sometimes the Test.More interface isn&#39;t quite enough. Fortunately, Test.More is built on top of Test.Builder, which provides a single, unified back end for any test library to use. This means two test libraries that both use Test.Builder <b>can be used together in the same program</b>.</p>

<p>If you simply want to do a little tweaking of how the tests behave, you can access the underlying Test.Builder object like so:</p>

<dl>
<dt><a name="builder"
><b>builder</b></a></dt>

<dd>
<pre>    var testBuilder = Test.More.builder();</pre>

<p>Returns the Test.Builder object underlying Test.More for you to play with.</p>

<dt><a name="beginAsync"
><b>beginAsync</b>
<dt><a name="endAsync"
><b>endAsync</b></a></dt>

<dd>
<pre>  var timeout = 3000;
  var asyncID = beginAsync(timeout);
  window.setTimeout(
      function () {
          Test.ok(true, &#34;Pass after 2 seconds&#34;);
          endAsync(asyncID);
      }, timeout - 1000
  );</pre>

<p>Sometimes you may need to run tests in an asynchronous process. Such processes can be started using <code>window.setTimeout()</code> or <code>window.setInterval()</code> in a browser, or by making an XMLHttpRequest call. In such cases, the tests might normally run <i>after</i> the test script has completed, and thus the summary message at the end of the test script will be incorrect--and the test results will appear after the summary.</p>

<p>To get around this problem, use beginAsync() to prevent the test script from finishing until you pass the ID returned by beginAsync() to endAsync(). If you&#39;ve called beginAsync() with the optional timout argument, then the test will finish if endAsync() has not been called with the appropriate ID before the timeout has elapsed. The timeout can be specified in milliseconds.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="See_Also"
>See Also</a></h1>

<dl>
<dt><a name="Test.Simple"
><a href="https://metacpan.org/pod/Test.Simple" class="podlinkpod"
>Test.Simple</a></a></dt>

<dd>
<p>If all of these test functions confuse you and you just want to write some simple tests. You can upgrade to Test.More later (it&#39;s forward compatible).</p>

<dt><a name="http://www.edwardh.com/jsunit/"
><a href="http://www.edwardh.com/jsunit/" class="podlinkurl"
>http://www.edwardh.com/jsunit/</a></a></dt>

<dd>
<p>JSUnit: elaborate xUnit-style testing framework.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Authors"
>Authors</a></h1>

<p>Michael G Schwern &#60;schwern@pobox.com&#62; with much inspiration from Joshua Pritikin&#39;s Test module and lots of help from Barrie Slaymaker, Tony Bowden, blackstar.co.uk, chromatic, Fergal Daly and the perl-qa gang. JavaScript implementation by David Wheeler &#60;david@kineticode.com&#62;.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Copyright"
>Copyright</a></h1>

<p>Copyright 2001, 2002, 2004 by Michael G Schwern &#60;schwern@pobox.com&#62;, 2005 by David Wheeler.</p>

<p>This program is free software; you can redistribute it and/or modify it under the terms of the Perl Artistic License or the GNU GPL.</p>

<p>See <a href="http://www.perl.com/perl/misc/Artistic.html" class="podlinkurl"
>http://www.perl.com/perl/misc/Artistic.html</a> and <a href="http://www.gnu.org/copyleft/gpl.html" class="podlinkurl"
>http://www.gnu.org/copyleft/gpl.html</a>.</p>

<!-- end doc -->

</body></html>
